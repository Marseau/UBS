/**
 * VALIDA√á√ÉO DETALHADA DOS DADOS DE CONVERSATION_HISTORY
 * Context Engineering COLEAM00 - Valida√ß√£o completa antes da implementa√ß√£o
 */

require('dotenv').config();
const { getAdminClient } = require('./dist/config/database.js');

async function validateConversationDataDetailed() {
    console.log('üî¨ VALIDA√á√ÉO DETALHADA DOS DADOS DE CONVERSATION_HISTORY');
    console.log('Context Engineering COLEAM00 - Verifica√ß√£o Completa Antes da Implementa√ß√£o');
    console.log('=' .repeat(80));

    try {
        const supabase = getAdminClient();
        const tenantId = '33b8c488-5aa9-4891-b335-701d10296681'; // Bella Vista Spa
        
        console.log(`üè™ Validando dados do tenant: ${tenantId}`);
        console.log('-'.repeat(80));

        // ========================================
        // 1. VALIDAR ESTRUTURA COMPLETA
        // ========================================
        console.log('\nüìã 1. VALIDANDO ESTRUTURA DA TABELA...');
        
        const { data: sampleRecord, error: structureError } = await supabase
            .from('conversation_history')
            .select('*')
            .eq('tenant_id', tenantId)
            .limit(1);

        if (structureError) {
            throw new Error(`Erro estrutura: ${structureError.message}`);
        }

        if (sampleRecord && sampleRecord.length > 0) {
            const record = sampleRecord[0];
            console.log('‚úÖ Campos dispon√≠veis e tipos:');
            
            Object.entries(record).forEach(([field, value]) => {
                const type = value === null ? 'null' : typeof value;
                const sample = value === null ? 'NULL' : 
                              typeof value === 'string' && value.length > 50 ? `${value.substring(0, 50)}...` :
                              JSON.stringify(value);
                console.log(`   ${field}: ${type} = ${sample}`);
            });
        }

        // ========================================
        // 2. VALIDAR DADOS DO PER√çODO (30 DIAS)
        // ========================================
        console.log('\nüìÖ 2. VALIDANDO DADOS DO PER√çODO (30 DIAS)...');
        
        const dateStart = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
        const dateEnd = new Date().toISOString();
        
        console.log(`üìä Per√≠odo: ${dateStart.split('T')[0]} at√© ${dateEnd.split('T')[0]}`);

        const { data: periodData, error: periodError } = await supabase
            .from('conversation_history')
            .select('*')
            .eq('tenant_id', tenantId)
            .gte('created_at', dateStart)
            .lte('created_at', dateEnd);

        if (periodError) {
            throw new Error(`Erro per√≠odo: ${periodError.message}`);
        }

        console.log(`‚úÖ Registros no per√≠odo: ${periodData?.length || 0}`);

        if (!periodData || periodData.length === 0) {
            console.log('‚ö†Ô∏è  NENHUM DADO NO PER√çODO - Expandindo para 90 dias...');
            
            const dateStart90 = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString();
            const { data: period90Data } = await supabase
                .from('conversation_history')
                .select('*')
                .eq('tenant_id', tenantId)
                .gte('created_at', dateStart90)
                .lte('created_at', dateEnd);
            
            console.log(`üìä Registros em 90 dias: ${period90Data?.length || 0}`);
            
            if (period90Data && period90Data.length > 0) {
                // Usar dados de 90 dias para valida√ß√£o
                periodData = period90Data;
                console.log('‚úÖ Usando dados de 90 dias para valida√ß√£o');
            }
        }

        if (!periodData || periodData.length === 0) {
            console.log('‚ùå NENHUM DADO ENCONTRADO PARA ESTE TENANT');
            return;
        }

        // ========================================
        // 3. VALIDAR CONVERSATION_OUTCOME
        // ========================================
        console.log('\nüéØ 3. VALIDANDO CONVERSATION_OUTCOME...');
        
        const outcomeData = periodData.filter(r => r.conversation_outcome);
        const outcomeDistribution = {};
        
        outcomeData.forEach(record => {
            outcomeDistribution[record.conversation_outcome] = (outcomeDistribution[record.conversation_outcome] || 0) + 1;
        });

        console.log(`üìä Registros com outcome: ${outcomeData.length}/${periodData.length} (${((outcomeData.length/periodData.length)*100).toFixed(1)}%)`);
        
        if (Object.keys(outcomeDistribution).length > 0) {
            console.log('üìà Distribui√ß√£o de outcomes:');
            Object.entries(outcomeDistribution)
                .sort(([,a], [,b]) => b - a)
                .forEach(([outcome, count]) => {
                    const percentage = ((count / outcomeData.length) * 100).toFixed(1);
                    console.log(`   ${outcome}: ${count} (${percentage}%)`);
                });
        } else {
            console.log('‚ö†Ô∏è  Nenhum outcome encontrado');
        }

        // ========================================
        // 4. VALIDAR INTENT_DETECTED
        // ========================================
        console.log('\nü§ñ 4. VALIDANDO INTENT_DETECTED...');
        
        const intentData = periodData.filter(r => r.intent_detected);
        const intentDistribution = {};
        
        intentData.forEach(record => {
            intentDistribution[record.intent_detected] = (intentDistribution[record.intent_detected] || 0) + 1;
        });

        console.log(`üìä Registros com intent: ${intentData.length}/${periodData.length} (${((intentData.length/periodData.length)*100).toFixed(1)}%)`);
        
        if (Object.keys(intentDistribution).length > 0) {
            console.log('üéØ Top intents detectados:');
            Object.entries(intentDistribution)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5)
                .forEach(([intent, count]) => {
                    const percentage = ((count / intentData.length) * 100).toFixed(1);
                    console.log(`   ${intent}: ${count} (${percentage}%)`);
                });
        } else {
            console.log('‚ö†Ô∏è  Nenhum intent encontrado');
        }

        // ========================================
        // 5. VALIDAR CONFIDENCE_SCORE
        // ========================================
        console.log('\nüìä 5. VALIDANDO CONFIDENCE_SCORE...');
        
        const confidenceData = periodData.filter(r => r.confidence_score !== null);
        
        if (confidenceData.length > 0) {
            const scores = confidenceData.map(r => r.confidence_score);
            const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
            const highConfidence = scores.filter(s => s >= 0.9).length;
            const mediumConfidence = scores.filter(s => s >= 0.7 && s < 0.9).length;
            const lowConfidence = scores.filter(s => s < 0.7).length;

            console.log(`üìä Registros com confidence: ${confidenceData.length}/${periodData.length} (${((confidenceData.length/periodData.length)*100).toFixed(1)}%)`);
            console.log(`üìà Confidence m√©dio: ${avgScore.toFixed(3)}`);
            console.log(`üü¢ Alta (‚â•0.9): ${highConfidence} (${((highConfidence/scores.length)*100).toFixed(1)}%)`);
            console.log(`üü° M√©dia (0.7-0.9): ${mediumConfidence} (${((mediumConfidence/scores.length)*100).toFixed(1)}%)`);
            console.log(`üî¥ Baixa (<0.7): ${lowConfidence} (${((lowConfidence/scores.length)*100).toFixed(1)}%)`);
        } else {
            console.log('‚ö†Ô∏è  Nenhum confidence_score encontrado');
        }

        // ========================================
        // 6. VALIDAR DADOS DE CUSTO
        // ========================================
        console.log('\nüí∞ 6. VALIDANDO DADOS DE CUSTO...');
        
        const costData = periodData.filter(r => r.api_cost_usd || r.processing_cost_usd || r.tokens_used);
        
        if (costData.length > 0) {
            const apiCosts = costData.filter(r => r.api_cost_usd).map(r => r.api_cost_usd);
            const processingCosts = costData.filter(r => r.processing_cost_usd).map(r => r.processing_cost_usd);
            const tokens = costData.filter(r => r.tokens_used).map(r => r.tokens_used);
            
            console.log(`üìä Registros com dados de custo: ${costData.length}/${periodData.length} (${((costData.length/periodData.length)*100).toFixed(1)}%)`);
            
            if (apiCosts.length > 0) {
                const avgApiCost = apiCosts.reduce((sum, cost) => sum + cost, 0) / apiCosts.length;
                const totalApiCost = apiCosts.reduce((sum, cost) => sum + cost, 0);
                console.log(`üíµ API Cost m√©dio: $${avgApiCost.toFixed(6)}`);
                console.log(`üíµ API Cost total: $${totalApiCost.toFixed(4)}`);
            }
            
            if (processingCosts.length > 0) {
                const avgProcessingCost = processingCosts.reduce((sum, cost) => sum + cost, 0) / processingCosts.length;
                console.log(`‚öôÔ∏è  Processing Cost m√©dio: $${avgProcessingCost.toFixed(6)}`);
            }
            
            if (tokens.length > 0) {
                const avgTokens = tokens.reduce((sum, token) => sum + token, 0) / tokens.length;
                const totalTokens = tokens.reduce((sum, token) => sum + token, 0);
                console.log(`üî¢ Tokens m√©dios: ${avgTokens.toFixed(1)}`);
                console.log(`üî¢ Tokens totais: ${totalTokens}`);
            }
        } else {
            console.log('‚ö†Ô∏è  Nenhum dado de custo encontrado');
        }

        // ========================================
        // 7. VALIDAR CONVERSATION_CONTEXT
        // ========================================
        console.log('\nüìù 7. VALIDANDO CONVERSATION_CONTEXT...');
        
        const contextData = periodData.filter(r => r.conversation_context);
        
        if (contextData.length > 0) {
            console.log(`üìä Registros com context: ${contextData.length}/${periodData.length} (${((contextData.length/periodData.length)*100).toFixed(1)}%)`);
            
            // Analisar estrutura do contexto
            const sampleContext = contextData[0].conversation_context;
            console.log('üìÑ Estrutura do contexto:');
            
            if (typeof sampleContext === 'object') {
                Object.keys(sampleContext).forEach(key => {
                    console.log(`   ${key}: ${typeof sampleContext[key]} = ${sampleContext[key]}`);
                });
                
                // Extrair dura√ß√£o se dispon√≠vel
                const durationsData = contextData
                    .filter(r => r.conversation_context && r.conversation_context.duration_minutes)
                    .map(r => parseFloat(r.conversation_context.duration_minutes));
                
                if (durationsData.length > 0) {
                    const avgDuration = durationsData.reduce((sum, dur) => sum + dur, 0) / durationsData.length;
                    const totalDuration = durationsData.reduce((sum, dur) => sum + dur, 0);
                    console.log(`‚è±Ô∏è  Dura√ß√£o m√©dia: ${avgDuration.toFixed(1)} min`);
                    console.log(`‚è±Ô∏è  Dura√ß√£o total: ${totalDuration.toFixed(1)} min`);
                }
            }
        } else {
            console.log('‚ö†Ô∏è  Nenhum conversation_context encontrado');
        }

        // ========================================
        // 8. RESUMO DA VALIDA√á√ÉO
        // ========================================
        console.log('\n' + '='.repeat(80));
        console.log('üìã RESUMO DA VALIDA√á√ÉO');
        console.log('='.repeat(80));
        console.log(`‚úÖ DADOS VALIDADOS PARA TENANT: ${tenantId}`);
        console.log(`üìä Total de registros: ${periodData.length}`);
        console.log(`üéØ Outcomes dispon√≠veis: ${(outcomeData.length > 0) ? '‚úÖ' : '‚ùå'} (${outcomeData.length})`);
        console.log(`ü§ñ Intents dispon√≠veis: ${(intentData.length > 0) ? '‚úÖ' : '‚ùå'} (${intentData.length})`);
        console.log(`üìä Confidence dispon√≠vel: ${(confidenceData.length > 0) ? '‚úÖ' : '‚ùå'} (${confidenceData.length})`);
        console.log(`üí∞ Custo dispon√≠vel: ${(costData.length > 0) ? '‚úÖ' : '‚ùå'} (${costData.length})`);
        console.log(`üìù Context dispon√≠vel: ${(contextData.length > 0) ? '‚úÖ' : '‚ùå'} (${contextData.length})`);

        console.log('\nüöÄ PRONTO PARA IMPLEMENTA√á√ÉO:');
        if (outcomeData.length > 0) console.log('   ‚úÖ M√©tricas de Convers√£o');
        if (intentData.length > 0 && confidenceData.length > 0) console.log('   ‚úÖ M√©tricas de IA');
        if (costData.length > 0) console.log('   ‚úÖ M√©tricas de Custo');
        if (contextData.length > 0) console.log('   ‚úÖ M√©tricas de Qualidade');
        
        console.log('\nüìà QUALIDADE DOS DADOS:');
        const dataQualityScore = [
            outcomeData.length > 0 ? 25 : 0,
            intentData.length > 0 ? 25 : 0,
            confidenceData.length > 0 ? 25 : 0,
            costData.length > 0 ? 25 : 0
        ].reduce((sum, score) => sum + score, 0);
        
        console.log(`   üìä Score de Qualidade: ${dataQualityScore}/100`);
        console.log(`   ${dataQualityScore >= 75 ? 'üü¢ EXCELENTE' : dataQualityScore >= 50 ? 'üü° BOM' : 'üî¥ LIMITADO'}`);

    } catch (error) {
        console.error('‚ùå Erro durante valida√ß√£o:', error.message);
        console.error(error.stack);
    }
}

// Executar valida√ß√£o
validateConversationDataDetailed();