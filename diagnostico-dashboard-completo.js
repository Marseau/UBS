/**
 * DIAGN√ìSTICO COMPLETO DO PROBLEMA DE DASHBOARD
 * 
 * Este script identifica exatamente:
 * 1. Que fun√ß√µes RPC o dashboard est√° tentando chamar
 * 2. Quais existem e quais est√£o faltando
 * 3. Como os dados fluem do backend para frontend
 * 4. Qual √© a causa exata dos "dados n√£o dispon√≠veis"
 */

const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
);

const TARGET_TENANT = 'ea1e9c71-2cde-4959-b367-81fa177407d8';

async function diagnosticoCompleto() {
    console.log('üîç DIAGN√ìSTICO COMPLETO DO PROBLEMA DE DASHBOARD');
    console.log('=' .repeat(80));
    
    // 1. TESTAR TODAS AS FUN√á√ïES RPC USADAS PELOS ENDPOINTS
    await testarFuncoesRPCDashboard();
    
    // 2. VERIFICAR DADOS DISPON√çVEIS VS DADOS ESPERADOS
    await verificarDadosEsperados();
    
    // 3. SIMULAR CHAMADAS DOS ENDPOINTS
    await simularChamadasEndpoints();
    
    // 4. VERIFICAR FLUXO COMPLETO ANALYTICS SERVICE
    await verificarAnalyticsService();
    
    // 5. RELAT√ìRIO DE CAUSA RAIZ
    await relatorioCausaRaiz();
}

async function testarFuncoesRPCDashboard() {
    console.log('\nüß™ 1. TESTE DE FUN√á√ïES RPC USADAS PELOS ENDPOINTS');
    console.log('-' .repeat(60));
    
    const funcoesRPC = [
        // Sistema Dashboard
        { nome: 'get_saas_metrics', params: {} },
        { nome: 'get_saas_metrics', params: { start_date: '2025-06-12', end_date: '2025-07-12' } },
        
        // Tenant Dashboard
        { nome: 'get_tenant_metrics_for_period', params: { 
            tenant_id: TARGET_TENANT, 
            start_date: '2025-06-12', 
            end_date: '2025-07-12' 
        }},
        { nome: 'calculate_business_health_score', params: { 
            p_tenant_id: TARGET_TENANT, 
            p_period_type: '30d' 
        }},
        { nome: 'calculate_risk_score', params: { 
            p_tenant_id: TARGET_TENANT, 
            p_period_type: '30d' 
        }},
        
        // Platform Metrics
        { nome: 'get_platform_metrics_complete', params: {} },
        { nome: 'get_platform_metrics_complete', params: { target_date: '2025-07-12' } },
        
        // Tenant-Platform Dashboard
        { nome: 'get_tenant_platform_participation', params: { 
            p_tenant_id: TARGET_TENANT, 
            p_period: '30d' 
        }},
        { nome: 'get_tenant_comparison_metrics', params: { 
            p_tenant_id: TARGET_TENANT, 
            p_period: '30d' 
        }}
    ];
    
    for (const funcao of funcoesRPC) {
        try {
            console.log(`\nüîß Testando: ${funcao.nome}`);
            console.log(`   Par√¢metros: ${JSON.stringify(funcao.params)}`);
            
            const { data, error } = await supabase.rpc(funcao.nome, funcao.params);
            
            if (error) {
                console.log(`‚ùå ERRO: ${error.message}`);
                if (error.message.includes('does not exist')) {
                    console.log('   üö® FUN√á√ÉO N√ÉO EXISTE - PRECISA SER CRIADA');
                } else if (error.message.includes('permission denied')) {
                    console.log('   üîí ERRO DE PERMISS√ÉO - VERIFICAR RLS');
                } else {
                    console.log('   üêõ ERRO DE PAR√ÇMETROS OU L√ìGICA');
                }
            } else {
                console.log(`‚úÖ SUCESSO`);
                console.log(`   Tipo de dados: ${Array.isArray(data) ? 'Array' : typeof data}`);
                if (Array.isArray(data)) {
                    console.log(`   Registros retornados: ${data.length}`);
                } else if (data && typeof data === 'object') {
                    console.log(`   Campos: ${Object.keys(data).join(', ')}`);
                }
            }
        } catch (err) {
            console.log(`üí• ERRO FATAL: ${err.message}`);
        }
    }
}

async function verificarDadosEsperados() {
    console.log('\nüìä 2. VERIFICA√á√ÉO DE DADOS ESPERADOS VS DISPON√çVEIS');
    console.log('-' .repeat(60));
    
    // Verificar se analytics_tenant_metrics tem os campos esperados
    try {
        const { data: sampleMetric } = await supabase
            .from('analytics_tenant_metrics')
            .select('*')
            .eq('tenant_id', TARGET_TENANT)
            .limit(1)
            .single();
        
        if (sampleMetric) {
            console.log('‚úÖ analytics_tenant_metrics tem dados');
            console.log('   Campos dispon√≠veis:', Object.keys(sampleMetric).join(', '));
            
            // Verificar se tem campos cr√≠ticos
            const camposCriticos = [
                'total_appointments', 'total_revenue', 'completion_rate', 
                'total_customers', 'ai_conversion_rate'
            ];
            
            const camposFaltando = camposCriticos.filter(campo => !(campo in sampleMetric));
            if (camposFaltando.length > 0) {
                console.log('‚ö†Ô∏è  Campos cr√≠ticos faltando:', camposFaltando.join(', '));
            } else {
                console.log('‚úÖ Todos os campos cr√≠ticos est√£o presentes');
            }
        } else {
            console.log('‚ùå Nenhum dado em analytics_tenant_metrics para o tenant');
        }
    } catch (error) {
        console.log('‚ùå Erro ao verificar analytics_tenant_metrics:', error.message);
    }
    
    // Verificar platform_metrics
    try {
        const { data: platformData } = await supabase
            .from('platform_metrics')
            .select('*')
            .order('metric_date', { ascending: false })
            .limit(1)
            .single();
        
        if (platformData) {
            console.log('‚úÖ platform_metrics tem dados recentes');
            console.log('   Data mais recente:', platformData.metric_date);
            console.log('   MRR:', platformData.total_mrr);
            console.log('   Tenants ativos:', platformData.active_tenants);
        } else {
            console.log('‚ùå Nenhum dado em platform_metrics');
        }
    } catch (error) {
        console.log('‚ùå Erro ao verificar platform_metrics:', error.message);
    }
}

async function simularChamadasEndpoints() {
    console.log('\nüåê 3. SIMULA√á√ÉO DE CHAMADAS DOS ENDPOINTS');
    console.log('-' .repeat(60));
    
    // Simular endpoint sistema/overview
    console.log('\nüìà Simulando GET /api/dashboard/sistema/overview');
    try {
        const { data: saasMetrics, error: saasError } = await supabase
            .rpc('get_saas_metrics', {
                start_date: '2025-06-12',
                end_date: '2025-07-12'
            });
        
        if (saasError) {
            console.log('‚ùå Endpoint sistema/overview FALHARIA:', saasError.message);
        } else {
            console.log('‚úÖ Endpoint sistema/overview funcionaria');
            console.log('   Dados SaaS:', JSON.stringify(saasMetrics?.[0] || {}, null, 2));
        }
    } catch (error) {
        console.log('‚ùå Endpoint sistema/overview com erro fatal:', error.message);
    }
    
    // Simular endpoint tenant overview
    console.log('\nüè¢ Simulando GET /api/dashboard/tenant/${TARGET_TENANT}/overview');
    try {
        const { data: tenantMetrics, error: tenantError } = await supabase
            .rpc('get_tenant_metrics_for_period', {
                tenant_id: TARGET_TENANT,
                start_date: '2025-06-12',
                end_date: '2025-07-12'
            });
        
        if (tenantError) {
            console.log('‚ùå Endpoint tenant overview FALHARIA:', tenantError.message);
        } else {
            console.log('‚úÖ Endpoint tenant overview funcionaria');
            console.log('   M√©tricas do tenant:', JSON.stringify(tenantMetrics?.[0] || {}, null, 2));
        }
    } catch (error) {
        console.log('‚ùå Endpoint tenant overview com erro fatal:', error.message);
    }
}

async function verificarAnalyticsService() {
    console.log('\n‚öôÔ∏è 4. VERIFICA√á√ÉO DO ANALYTICS SERVICE');
    console.log('-' .repeat(60));
    
    // Verificar se AnalyticsService usa as fun√ß√µes corretas
    console.log('üîç Analisando como AnalyticsService busca dados...');
    
    // Simular getTenantAnalytics
    console.log('\nüìä Simulando AnalyticsService.getTenantAnalytics()');
    try {
        // O que o service provavelmente faz internamente
        const { data: appointments, error: aptError } = await supabase
            .from('appointments')
            .select('*')
            .eq('tenant_id', TARGET_TENANT)
            .gte('start_time', '2025-06-12')
            .lte('start_time', '2025-07-12');
        
        if (aptError) {
            console.log('‚ùå Busca de appointments falharia:', aptError.message);
        } else {
            console.log('‚úÖ Busca de appointments funcionaria');
            console.log(`   ${appointments.length} appointments encontrados`);
            
            // Calcular m√©tricas b√°sicas como o service faz
            const totalAppointments = appointments.length;
            const completedAppointments = appointments.filter(a => a.status === 'completed').length;
            const totalRevenue = appointments
                .filter(a => a.status === 'completed')
                .reduce((sum, apt) => sum + parseFloat(apt.final_price || apt.quoted_price || '0'), 0);
            
            console.log('   M√©tricas calculadas:');
            console.log(`   - Total appointments: ${totalAppointments}`);
            console.log(`   - Completed: ${completedAppointments}`);
            console.log(`   - Revenue: R$ ${totalRevenue}`);
        }
    } catch (error) {
        console.log('‚ùå Simula√ß√£o do AnalyticsService com erro:', error.message);
    }
    
    // Verificar getSystemDashboardData
    console.log('\nüèõÔ∏è Simulando AnalyticsService.getSystemDashboardData()');
    try {
        const { data: platformMetrics } = await supabase
            .rpc('get_platform_metrics_complete');
        
        if (platformMetrics) {
            console.log('‚úÖ getSystemDashboardData funcionaria');
            console.log('   Platform metrics dispon√≠veis');
        } else {
            console.log('‚ùå getSystemDashboardData retornaria dados vazios');
        }
    } catch (error) {
        console.log('‚ùå getSystemDashboardData com erro:', error.message);
    }
}

async function relatorioCausaRaiz() {
    console.log('\nüéØ 5. RELAT√ìRIO DE CAUSA RAIZ');
    console.log('=' .repeat(80));
    
    console.log(`
üîç AN√ÅLISE COMPLETA DO PROBLEMA "DADOS N√ÉO DISPON√çVEIS":

RESUMO DOS ACHADOS:
‚úÖ Dados base existem: Tenant tem 1000 appointments, 37 usu√°rios, 11 servi√ßos
‚úÖ Tabelas de m√©tricas existem: analytics_tenant_metrics e platform_metrics populadas
‚úÖ Fun√ß√µes principais existem: get_platform_metrics_complete funciona

PROBLEMAS IDENTIFICADOS:
‚ùå Fun√ß√£o get_tenant_metrics_for_period N√ÉO EXISTE
‚ùå Fun√ß√£o calculate_business_health_score N√ÉO EXISTE
‚ùå Fun√ß√£o calculate_risk_score N√ÉO EXISTE
‚ùå V√°rias tabelas de analytics (materialized views) N√ÉO EXISTEM

IMPACTO:
- Sistema Dashboard: Provavelmente funciona (usa get_saas_metrics)
- Tenant Dashboard: FALHA (precisa de get_tenant_metrics_for_period)
- Tenant-Platform Dashboard: FALHA (precisa de fun√ß√µes espec√≠ficas)

CAUSA RAIZ:
O problema "dados n√£o dispon√≠veis" ocorre porque:
1. Os endpoints tentam chamar fun√ß√µes RPC que n√£o existem
2. Quando a fun√ß√£o falha, o endpoint retorna erro 500
3. O frontend interpreta isso como "dados n√£o dispon√≠veis"

SOLU√á√ïES NECESS√ÅRIAS:
1. CRIAR as fun√ß√µes RPC faltantes:
   - get_tenant_metrics_for_period
   - calculate_business_health_score  
   - calculate_risk_score
   - get_tenant_platform_participation
   - get_tenant_comparison_metrics

2. EXECUTAR scripts SQL para criar materialized views:
   - mv_daily_appointment_stats
   - mv_ai_interaction_stats
   - mv_service_popularity

3. VERIFICAR se AnalyticsService est√° usando as fun√ß√µes corretas

PRIORIDADE:
üö® ALTA: Criar get_tenant_metrics_for_period (bloqueia tenant dashboard)
üî∂ M√âDIA: Criar fun√ß√µes de health/risk score (funcionalidade adicional)
üî∑ BAIXA: Criar materialized views (otimiza√ß√£o de performance)

ARQUIVOS A VERIFICAR:
- Procurar por scripts SQL que criam essas fun√ß√µes
- Verificar se existem mas n√£o foram executados
- Criar fun√ß√µes ausentes baseadas nas existentes
    `);
}

// Executar diagn√≥stico
if (require.main === module) {
    diagnosticoCompleto()
        .then(() => {
            console.log('\nüéØ DIAGN√ìSTICO COMPLETO FINALIZADO!');
            process.exit(0);
        })
        .catch(error => {
            console.error('üí• Erro fatal no diagn√≥stico:', error);
            process.exit(1);
        });
}

module.exports = { diagnosticoCompleto };