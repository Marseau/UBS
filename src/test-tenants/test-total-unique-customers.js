#!/usr/bin/env node

/**
 * TESTE DA M√âTRICA TOTAL_UNIQUE_CUSTOMERS
 * 
 * Valida o c√°lculo de clientes √∫nicos por tenant
 * Analisa diferentes fontes de dados de clientes
 */

const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabase = createClient(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
);

/**
 * An√°lise de fonte de dados de clientes
 */
async function analyzeCustomerDataSources(tenantId) {
    console.log(`üîç Analisando fontes de dados de clientes para tenant ${tenantId.substring(0, 8)}`);
    
    try {
        // 1. Clientes via appointments
        const { data: appointmentUsers, error: appointmentError } = await supabase
            .from('appointments')
            .select('user_id, created_at, status')
            .eq('tenant_id', tenantId)
            .not('user_id', 'is', null);
            
        if (appointmentError) throw appointmentError;
        
        // 2. Clientes via conversation_history
        const { data: conversationUsers, error: conversationError } = await supabase
            .from('conversation_history')
            .select('conversation_context, created_at')
            .eq('tenant_id', tenantId)
            .not('conversation_context', 'is', null);
            
        if (conversationError) throw conversationError;
        
        // 3. Clientes via users (se existir rela√ß√£o direta)
        const { data: directUsers, error: directError } = await supabase
            .from('users')
            .select('id, created_at')
            .limit(5); // Sample para verificar estrutura
            
        if (directError) throw directError;
        
        // An√°lise dos dados
        const uniqueAppointmentUsers = new Set(appointmentUsers?.map(a => a.user_id) || []);
        const uniqueConversationUsers = new Set();
        
        conversationUsers?.forEach(conv => {
            const userId = conv.conversation_context?.user_id;
            if (userId) uniqueConversationUsers.add(userId);
        });
        
        console.log(`   üìä FONTES DE CLIENTES:`);
        console.log(`      Via appointments: ${uniqueAppointmentUsers.size} clientes √∫nicos`);
        console.log(`      Via conversations: ${uniqueConversationUsers.size} clientes √∫nicos`);
        console.log(`      Tabela users: ${directUsers?.length} registros (sample)`);
        
        // Interse√ß√£o entre fontes
        const intersection = new Set([...uniqueAppointmentUsers].filter(x => uniqueConversationUsers.has(x)));
        const appointmentOnly = new Set([...uniqueAppointmentUsers].filter(x => !uniqueConversationUsers.has(x)));
        const conversationOnly = new Set([...uniqueConversationUsers].filter(x => !uniqueAppointmentUsers.has(x)));
        
        console.log(`   üîÑ OVERLAP ENTRE FONTES:`);
        console.log(`      Em ambas: ${intersection.size}`);
        console.log(`      S√≥ appointments: ${appointmentOnly.size}`);
        console.log(`      S√≥ conversations: ${conversationOnly.size}`);
        
        // Verificar alguns status de appointments
        if (appointmentUsers?.length > 0) {
            const statusCount = {};
            appointmentUsers.forEach(apt => {
                statusCount[apt.status] = (statusCount[apt.status] || 0) + 1;
            });
            
            console.log(`   üìà STATUS DOS APPOINTMENTS:`);
            Object.entries(statusCount).forEach(([status, count]) => {
                console.log(`      ${status}: ${count}`);
            });
        }
        
        return {
            appointment_users: uniqueAppointmentUsers.size,
            conversation_users: uniqueConversationUsers.size,
            intersection: intersection.size,
            appointment_only: appointmentOnly.size,
            conversation_only: conversationOnly.size
        };
        
    } catch (error) {
        console.error(`   üí• Erro na an√°lise: ${error.message}`);
        throw error;
    }
}

/**
 * Testar m√©trica atual (sem per√≠odo)
 */
async function testCurrentImplementation(tenantId) {
    console.log(`üß™ Testando implementa√ß√£o atual para tenant ${tenantId.substring(0, 8)}`);
    
    try {
        const { data: uniqueUsers, error } = await supabase
            .from('appointments')
            .select('user_id')
            .eq('tenant_id', tenantId)
            .not('user_id', 'is', null);
        
        if (error) throw error;
        
        const uniqueCount = new Set(uniqueUsers?.map(u => u.user_id) || []).size;
        
        console.log(`   ‚úÖ Implementa√ß√£o atual: ${uniqueCount} clientes √∫nicos`);
        console.log(`   üìù M√©todo: appointments.user_id √∫nicos`);
        console.log(`   ‚ö†Ô∏è  SEM filtro de per√≠odo - dados hist√≥ricos completos`);
        
        return { count: uniqueCount };
        
    } catch (error) {
        console.error(`   üí• Erro: ${error.message}`);
        throw error;
    }
}

/**
 * Propor implementa√ß√£o com per√≠odo
 */
async function testWithPeriodFilter(tenantId, periodDays) {
    console.log(`üìÖ Testando com filtro de per√≠odo ${periodDays}d para tenant ${tenantId.substring(0, 8)}`);
    
    try {
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - periodDays);
        
        console.log(`   üìÖ Per√≠odo: ${startDate.toISOString().split('T')[0]} at√© ${endDate.toISOString().split('T')[0]}`);
        
        // Clientes com appointments no per√≠odo
        const { data: periodAppointments, error: appointmentError } = await supabase
            .from('appointments')
            .select('user_id, created_at, status')
            .eq('tenant_id', tenantId)
            .gte('created_at', startDate.toISOString())
            .lte('created_at', endDate.toISOString())
            .not('user_id', 'is', null);
            
        if (appointmentError) throw appointmentError;
        
        // Clientes com conversas no per√≠odo 
        const { data: periodConversations, error: conversationError } = await supabase
            .from('conversation_history')
            .select('conversation_context, created_at')
            .eq('tenant_id', tenantId)
            .gte('created_at', startDate.toISOString())
            .lte('created_at', endDate.toISOString())
            .not('conversation_context', 'is', null);
            
        if (conversationError) throw conversationError;
        
        // Unificar clientes √∫nicos do per√≠odo
        const periodUsers = new Set();
        
        periodAppointments?.forEach(apt => {
            if (apt.user_id) periodUsers.add(apt.user_id);
        });
        
        periodConversations?.forEach(conv => {
            const userId = conv.conversation_context?.user_id;
            if (userId) periodUsers.add(userId);
        });
        
        const appointmentOnlyCount = new Set(periodAppointments?.map(a => a.user_id) || []).size;
        const conversationOnlyCount = new Set();
        periodConversations?.forEach(conv => {
            const userId = conv.conversation_context?.user_id;
            if (userId) conversationOnlyCount.add(userId);
        });
        
        console.log(`   üìä CLIENTES NO PER√çODO ${periodDays}d:`);
        console.log(`      Via appointments: ${appointmentOnlyCount}`);
        console.log(`      Via conversations: ${conversationOnlyCount.size}`);
        console.log(`      TOTAL √öNICO: ${periodUsers.size}`);
        
        return {
            period_days: periodDays,
            appointment_customers: appointmentOnlyCount,
            conversation_customers: conversationOnlyCount.size,
            total_unique: periodUsers.size
        };
        
    } catch (error) {
        console.error(`   üí• Erro: ${error.message}`);
        throw error;
    }
}

/**
 * Executar todos os testes
 */
async function runTests() {
    console.log('üß™ TESTE DA M√âTRICA TOTAL_UNIQUE_CUSTOMERS');
    console.log('='.repeat(70));
    
    try {
        // Buscar tenants para teste
        const { data: tenants, error } = await supabase
            .from('tenants')
            .select('id, name')
            .eq('status', 'active');
        
        if (error) throw error;
        if (!tenants || tenants.length === 0) {
            console.log('‚ùå Nenhum tenant ativo encontrado');
            return;
        }
        
        console.log(`üìä Testando com ${tenants.length} tenants:`)
        tenants.forEach((tenant, index) => {
            console.log(`   ${index + 1}. ${tenant.name} (${tenant.id.substring(0, 8)})`);
        });
        
        for (const tenant of tenants) {
            console.log(`\nüè¢ TENANT: ${tenant.name}`);
            console.log('-'.repeat(60));
            
            // 1. An√°lise de fontes
            const sourceAnalysis = await analyzeCustomerDataSources(tenant.id);
            
            // 2. Teste implementa√ß√£o atual
            const currentResult = await testCurrentImplementation(tenant.id);
            
            // 3. Teste com per√≠odos
            const periods = [7, 30, 90];
            for (const period of periods) {
                await testWithPeriodFilter(tenant.id, period);
            }
        }
        
        console.log('\nüìà AN√ÅLISE DA M√âTRICA:');
        console.log('='.repeat(60));
        console.log('‚ùå PROBLEMA 1: Sem filtro de per√≠odo - dados hist√≥ricos');
        console.log('‚ùå PROBLEMA 2: Fonte √∫nica (appointments) pode ser limitada');
        console.log('‚ùå PROBLEMA 3: N√£o diferencia por status de appointment');
        console.log('');
        console.log('üí° RECOMENDA√á√ïES:');
        console.log('‚úÖ Adicionar filtro de per√≠odo (7d/30d/90d)');
        console.log('‚úÖ Unificar fontes: appointments + conversations');
        console.log('‚úÖ Considerar status de appointments v√°lidos');
        console.log('‚úÖ M√©trica deveria ser "active_customers" no per√≠odo');
        
        console.log('\n‚úÖ TESTE CONCLU√çDO');
        
    } catch (error) {
        console.error('üí• ERRO NO TESTE:', error);
        process.exit(1);
    }
}

// Executar teste
if (require.main === module) {
    runTests().then(() => {
        process.exit(0);
    }).catch(error => {
        console.error('Erro fatal:', error);
        process.exit(1);
    });
}

module.exports = { 
    analyzeCustomerDataSources, 
    testCurrentImplementation,
    testWithPeriodFilter 
};