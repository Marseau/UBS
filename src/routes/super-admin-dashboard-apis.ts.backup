/**
 * APIs REST para Super Admin Dashboard
 * Endpoint: /api/super-admin/*
 * 
 * Fornece dados para todos os KPIs e gr√°ficos do dashboard:
 * - 8 KPIs estrat√©gicos da plataforma  
 * - 4 gr√°ficos de an√°lise
 * - Insights estrat√©gicos e rankings
 * - Dados para tabelas de distor√ß√£o/upsell/churn
 */

import { Router } from 'express';
import { getAdminClient } from '../config/database';
import { getAdminClientExtended } from '../config/database-extended';

const router = Router();

// Fun√ß√£o para obter taxa de c√¢mbio USD->BRL (obtida da internet)
async function getUsdToBrlRate(): Promise<number> {
    // Taxa atual obtida da internet: 1 USD = 5.56 BRL
    // Em produ√ß√£o, isso poderia chamar uma API externa em tempo real
    return 5.56;
}

// Fun√ß√£o para calcular m√©tricas corretas da plataforma usando platform_metrics
async function calculatePlatformUsageCost(periodDays: number = 30) {
    const client = getAdminClientExtended();
    const usdRate = await getUsdToBrlRate();
    
    console.log(`üí∞ Calculando m√©tricas da plataforma com dados REAIS (per√≠odo: ${periodDays} dias, taxa: ${usdRate})`);
    
    try {
        // =====================================================
        // 1. BUSCAR DADOS DOS PLATFORM_METRICS (DADOS CORRETOS)
        // =====================================================
        
        const { data: platformData, error: platformError } = await client
            .from('platform_metrics')
            .select('*')
            .eq('period_days', periodDays)
            .order('calculation_date', { ascending: false })
            .limit(1)
            .single();
        
        if (platformError) {
            console.error('‚ùå Erro ao buscar platform_metrics:', platformError);
            return null;
        }
        
        if (!platformData) {
            console.warn('‚ö†Ô∏è Nenhum platform_metrics encontrado');
            return null;
        }
        
        // =====================================================
        // 2. USAR DADOS DA PLATFORM_METRICS (J√Å CALCULADOS)
        // =====================================================
        
        const totals = {
            total_revenue_usd: (platformData.platform_mrr || 0) / usdRate, // Converter BRL para USD
            total_appointments: platformData.total_appointments || 0,
            total_customers: platformData.total_customers || 0,
            active_tenants: platformData.active_tenants || 0,
            total_conversations: platformData.total_ai_interactions || 0, // Assumir que AI interactions representam conversas
            total_ai_interactions: platformData.total_ai_interactions || 0,
            total_chat_minutes: platformData.total_chat_minutes || 0,
            spam_conversations: 0,
            valid_conversations: platformData.total_ai_interactions || 0,
            spam_rate_pct: platformData.spam_rate_pct || 0,
            cancellation_rate_pct: 0, // Calcular se necess√°rio
            cancelled_appointments: 0,
            rescheduled_appointments: 0
        };
        
        
        // =====================================================
        // C√ÅLCULOS USAGECOST (F√≥rmula estabelecida)
        // =====================================================
        
        // AI interactions: $0.02 per interaction
        const platform_ai_cost_usd = totals.total_ai_interactions * 0.02;
        
        // Conversations: $0.007 per conversation  
        const platform_conversation_cost_usd = totals.total_conversations * 0.007;
        
        // Chat minutes: $0.001 per minute
        const platform_chat_cost_usd = totals.total_chat_minutes * 0.001;
        
        // Total usage cost (USD)
        const platform_total_usage_cost_usd = platform_ai_cost_usd + platform_conversation_cost_usd + platform_chat_cost_usd;
        
        // =====================================================
        // CONVERS√ïES USD ‚Üí BRL
        // =====================================================
        
        const platform_revenue_brl = totals.total_revenue_usd * usdRate;
        const platform_total_usage_cost_brl = platform_total_usage_cost_usd * usdRate;
        const platform_ai_cost_brl = platform_ai_cost_usd * usdRate;
        const platform_conversation_cost_brl = platform_conversation_cost_usd * usdRate;
        
        // =====================================================
        // C√ÅLCULOS DE MARGEM
        // =====================================================
        
        const platform_margin_usd = totals.total_revenue_usd - platform_total_usage_cost_usd;
        const platform_margin_brl = platform_revenue_brl - platform_total_usage_cost_brl;
        const platform_margin_percentage = totals.total_revenue_usd > 0 ? 
            (platform_margin_usd / totals.total_revenue_usd) * 100 : 0;
        const platform_is_profitable = platform_margin_usd > 0;
        
        // Calcular ratio Receita/Uso
        const receita_uso_ratio_usd = totals.total_chat_minutes > 0 ? 
            totals.total_revenue_usd / totals.total_chat_minutes : 0;
        const receita_uso_ratio_brl = receita_uso_ratio_usd * usdRate;
        
        console.log(`üí∞ Platform UsageCost calculado: $${platform_total_usage_cost_usd.toFixed(4)} USD / R$ ${platform_total_usage_cost_brl.toFixed(2)} BRL`);
        console.log(`üìä Platform Margin: $${platform_margin_usd.toFixed(2)} USD / R$ ${platform_margin_brl.toFixed(2)} BRL (${platform_margin_percentage.toFixed(2)}%)`);
        
        return {
            // Totais da plataforma
            ...totals,
            
            // UsageCost metrics
            platform_usage_cost_usd: platform_total_usage_cost_usd,
            platform_usage_cost_brl: platform_total_usage_cost_brl,
            platform_ai_cost_usd,
            platform_ai_cost_brl,
            platform_conversation_cost_usd,
            platform_conversation_cost_brl,
            platform_margin_usd,
            platform_margin_brl,
            platform_margin_percentage,
            platform_is_profitable,
            usd_to_brl_rate: usdRate,
            
            // Ratios
            receita_uso_ratio_usd,
            receita_uso_ratio_brl,
            
            // Calculated fields
            operational_efficiency_pct: totals.total_conversations > 0 ? 
                (totals.total_appointments / totals.total_conversations) * 100 : 0
        };
        
    } catch (error) {
        console.error('‚ùå Erro no c√°lculo de UsageCost:', error);
        return null;
    }
}

// Middleware para log de todas as requisi√ß√µes
router.use((req, res, next) => {
    console.log(`[Super Admin API] ${req.method} ${req.path} - ${new Date().toISOString()}`);
    next();
});

/**
 * GET /api/super-admin/kpis
 * Retorna todos os 8 KPIs estrat√©gicos da plataforma com UsageCost e convers√£o BRL
 */
router.get('/kpis', async (req, res) => {
    try {
        const { period = '30' } = req.query;
        const periodDays = parseInt(period as string);
        
        console.log(`üîç Buscando KPIs da plataforma para per√≠odo: ${periodDays} dias`);
        
        // Calcular m√©tricas da plataforma com UsageCost
        const platformData = await calculatePlatformUsageCost(periodDays);
        
        if (!platformData) {
            console.log('‚ö†Ô∏è Dados da plataforma n√£o encontrados, usando valores padr√£o');
            return res.json({
                success: true,
                data: {
                    kpis: {
                        receitaUsoRatio: { value: 0, formatted: 'R$ 0,00', subtitle: 'R$ por minuto de chat', trend: { direction: 'down', text: 'Sem dados' } },
                        mrrPlatform: { value: 0, formatted: 'R$ 0', subtitle: 'Receita Recorrente Mensal', trend: { direction: 'neutral', text: 'Sem dados' } },
                        activeTenants: { value: 0, formatted: '0', subtitle: 'Clientes pagantes', trend: { direction: 'neutral', text: 'Sem dados' } },
                        operationalEfficiency: { value: 0, formatted: '0.0%', subtitle: 'Agendamentos / Conversas', trend: { direction: 'down', text: 'Sem dados' } },
                        spamRate: { value: 0, formatted: '0.0%', subtitle: '% conversas sem cadastro', trend: { direction: 'up', text: 'Sem dados' } },
                        cancellationRate: { value: 0, formatted: '0.0%', subtitle: '(Cancel + Remarc) / Total chats', trend: { direction: 'up', text: 'Sem dados' } },
                        totalAppointments: { value: 0, formatted: '0', subtitle: `√öltimos ${periodDays} dias`, trend: { direction: 'neutral', text: 'Sem dados' } },
                        aiInteractions: { value: 0, formatted: '0', subtitle: 'Respostas autom√°ticas', trend: { direction: 'neutral', text: 'Sem dados' } },
                        // Novos KPIs com UsageCost
                        usageCostBRL: { value: 0, formatted: 'R$ 0,00', subtitle: 'Custo de uso total', trend: { direction: 'down', text: 'Sem custos' } },
                        marginBRL: { value: 0, formatted: 'R$ 0,00', subtitle: 'Margem total da plataforma', trend: { direction: 'up', text: 'Sem dados' } },
                        marginPercentage: { value: 0, formatted: '0.0%', subtitle: 'Percentual de margem', trend: { direction: 'up', text: 'Sem dados' } }
                    },
                    metadata: { period_days: periodDays, has_data: false, is_mock_data: true }
                }
            });
        }
        
        const metrics = platformData;
        
        // Estruturar KPIs conforme esperado pelo frontend
        const kpis = {
            // KPI 1: Receita/Uso Ratio (RECEITA por minuto, n√£o UsageCost)
            receitaUsoRatio: {
                value: metrics.receita_uso_ratio_brl || 0,
                formatted: `R$ ${(metrics.receita_uso_ratio_brl || 0).toFixed(2)}`,
                subtitle: 'R$ receita por minuto de chat',
                trend: {
                    direction: (metrics.receita_uso_ratio_brl || 0) > 5 ? 'up' : 'down',
                    text: (metrics.receita_uso_ratio_brl || 0) > 5 ? 'Eficiente' : 'Subutilizado'
                }
            },
            
            // KPI 2: MRR da Plataforma (convertido para BRL)
            mrrPlatform: {
                value: metrics.total_revenue_usd * (metrics.usd_to_brl_rate || 5.56),
                formatted: `R$ ${(metrics.total_revenue_usd * (metrics.usd_to_brl_rate || 5.56)).toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`,
                subtitle: 'Receita Recorrente Mensal',
                trend: {
                    direction: 'up',
                    text: `${Math.round(metrics.active_tenants || 0)} tenants ativos`
                }
            },
            
            // KPI 3: Tenants Ativos (com total de tenants)
            activeTenants: {
                value: Math.round(metrics.active_tenants || 0),
                formatted: Math.round(metrics.active_tenants || 0).toString(),
                subtitle: `${Math.round(metrics.active_tenants || 0)} de ${Math.round(metrics.active_tenants || 0)} tenants`,
                trend: {
                    direction: 'up',
                    text: 'Todos ativos'
                }
            },
            
            // KPI 4: Efici√™ncia Operacional (dados reais: 2.119 appointments, X conversas)
            operationalEfficiency: {
                value: metrics.operational_efficiency_pct || 0,
                formatted: `${(metrics.operational_efficiency_pct || 0).toFixed(1)}%`,
                subtitle: `${metrics.total_appointments || 0} agendamentos / ${metrics.total_conversations || 0} conversas`,
                trend: {
                    direction: (metrics.operational_efficiency_pct || 0) > 15 ? 'up' : 'down',
                    text: (metrics.operational_efficiency_pct || 0) > 15 ? 'Alta convers√£o' : 'Baixa convers√£o'
                }
            },
            
            // KPI 5: Spam Rate (baseado em dados reais de confidence_score)
            spamRate: {
                value: metrics.spam_rate_pct || 0,
                formatted: `${(metrics.spam_rate_pct || 0).toFixed(1)}%`,
                subtitle: `${metrics.spam_conversations || 0} spam / ${metrics.total_conversations || 0} conversas`,
                trend: {
                    direction: (metrics.spam_rate_pct || 0) < 20 ? 'up' : 'down',
                    text: (metrics.spam_rate_pct || 0) < 20 ? 'Baixo spam' : 'Alto spam'
                }
            },
            
            // KPI 6: Taxa de Cancelamentos + Remarca√ß√µes (dados reais)
            cancellationRate: {
                value: metrics.cancellation_rate_pct || 0,
                formatted: `${(metrics.cancellation_rate_pct || 0).toFixed(1)}%`,
                subtitle: `${(metrics.cancelled_appointments || 0) + (metrics.rescheduled_appointments || 0)} de ${metrics.total_appointments || 0} appointments`,
                trend: {
                    direction: (metrics.cancellation_rate_pct || 0) < 15 ? 'up' : 'down',
                    text: (metrics.cancellation_rate_pct || 0) < 15 ? 'Baixa taxa' : 'Alta taxa'
                }
            },
            
            // KPI 7: Total de Agendamentos
            totalAppointments: {
                value: metrics.total_appointments || 0,
                formatted: (metrics.total_appointments || 0).toLocaleString('pt-BR'),
                subtitle: `√öltimos ${periodDays} dias`,
                trend: {
                    direction: 'up',
                    text: 'Crescimento constante'
                }
            },
            
            // KPI 8: Intera√ß√µes com IA
            aiInteractions: {
                value: metrics.total_ai_interactions || 0,
                formatted: (metrics.total_ai_interactions || 0).toLocaleString('pt-BR'),
                subtitle: 'Respostas autom√°ticas',
                trend: {
                    direction: 'up',
                    text: 'IA ativa'
                }
            },
            
            // =====================================================
            // NOVOS KPIs COM USAGECOST E CONVERS√ÉO BRL
            // =====================================================
            
            // KPI 9: UsageCost Total (BRL)
            usageCostBRL: {
                value: metrics.platform_usage_cost_brl || 0,
                formatted: `R$ ${(metrics.platform_usage_cost_brl || 0).toFixed(2)}`,
                subtitle: 'Custo de uso total (IA + Chat)',
                trend: {
                    direction: (metrics.platform_usage_cost_brl || 0) < 100 ? 'up' : 'down',
                    text: (metrics.platform_usage_cost_brl || 0) < 100 ? 'Baixo custo' : 'Alto custo'
                }
            },
            
            // KPI 10: Margem Total (BRL)
            marginBRL: {
                value: metrics.platform_margin_brl || 0,
                formatted: `R$ ${(metrics.platform_margin_brl || 0).toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 0 })}`,
                subtitle: 'Margem total da plataforma',
                trend: {
                    direction: (metrics.platform_margin_brl || 0) > 0 ? 'up' : 'down',
                    text: (metrics.platform_margin_brl || 0) > 0 ? 'Lucrativa' : 'Preju√≠zo'
                }
            },
            
            // KPI 11: Percentual de Margem
            marginPercentage: {
                value: metrics.platform_margin_percentage || 0,
                formatted: `${(metrics.platform_margin_percentage || 0).toFixed(1)}%`,
                subtitle: 'Percentual de margem',
                trend: {
                    direction: (metrics.platform_margin_percentage || 0) > 80 ? 'up' : 'down',
                    text: (metrics.platform_margin_percentage || 0) > 80 ? 'Excelente' : 'Baixa margem'
                }
            }
        };
        
        return res.json({
            success: true,
            data: {
                kpis,
                metadata: {
                    period_days: periodDays,
                    has_data: true,
                    usd_to_brl_rate: metrics.usd_to_brl_rate,
                    platform_totals: {
                        revenue_usd: metrics.total_revenue_usd,
                        revenue_brl: metrics.total_revenue_usd * (metrics.usd_to_brl_rate || 5.56),
                        usage_cost_usd: metrics.platform_usage_cost_usd,
                        usage_cost_brl: metrics.platform_usage_cost_brl,
                        margin_usd: metrics.platform_margin_usd,
                        margin_brl: metrics.platform_margin_brl,
                        margin_percentage: metrics.platform_margin_percentage,
                        is_profitable: metrics.platform_is_profitable,
                        active_tenants: Math.round(metrics.active_tenants || 0)
                    },
                    cost_breakdown: {
                        ai_cost_usd: metrics.platform_ai_cost_usd,
                        ai_cost_brl: metrics.platform_ai_cost_brl,
                        conversation_cost_usd: metrics.platform_conversation_cost_usd,
                        conversation_cost_brl: metrics.platform_conversation_cost_brl,
                        total_ai_interactions: metrics.total_ai_interactions,
                        total_conversations: metrics.total_conversations,
                        total_chat_minutes: metrics.total_chat_minutes
                    }
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de KPIs:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * GET /api/super-admin/charts/revenue-vs-usage-cost
 * Dados para o gr√°fico de Revenue vs UsageCost (scatter plot) com convers√£o BRL
 */
router.get('/charts/revenue-vs-usage-cost', async (req, res) => {
    try {
        const { period = '30' } = req.query;
        const periodDays = parseInt(period as string);
        const client = getAdminClientExtended();
        const usdRate = await getUsdToBrlRate();
        
        console.log(`üìä Buscando dados Revenue vs UsageCost para per√≠odo: ${periodDays} dias (Taxa: ${usdRate})`);
        
        // Buscar dados de todos os tenants da tabela tenant_metrics (JSONB)
        const { data: tenantData, error } = await client
            .from('tenant_metrics')
            .select('tenant_id, metric_data')
            .eq('metric_type', 'participation')
            .eq('period', `${periodDays}d`);
            
        if (error) {
            console.error('‚ùå Erro ao buscar dados dos tenants:', error);
            return res.status(500).json({
                success: false,
                error: 'Erro ao buscar dados do gr√°fico'
            });
        }
        
        // Buscar nomes dos tenants
        const { data: tenantsInfo, error: tenantsError } = await client
            .from('tenants')
            .select('id, business_name');
            
        const tenantNames: {[key: string]: string} = {};
        (tenantsInfo || []).forEach((tenant: any) => {
            tenantNames[tenant.id] = tenant.business_name || 'Tenant Desconhecido';
        });
        
        // Transformar dados para o formato do gr√°fico com UsageCost usando estrutura JSONB
        const chartData = (tenantData || []).map((tenant: any) => {
            const metricData = tenant.metric_data || {};
            
            // Extrair dados da estrutura JSONB
            const revenue = metricData.revenue?.participation_value || 79.90;
            const aiInteractions = metricData.ai_interactions?.count || 0;
            const chatMinutes = metricData.ai_interactions?.avg_chat_duration_minutes || 0;
            const conversations = aiInteractions; // Assumir 1 conversa por intera√ß√£o
            
            // Calcular UsageCost para este tenant
            const aiCost = aiInteractions * 0.02;
            const conversationCost = conversations * 0.007;
            const chatCost = chatMinutes * 0.001;
            const usageCostUSD = aiCost + conversationCost + chatCost;
            const usageCostBRL = usageCostUSD * usdRate;
            
            const revenueUSD = revenue / usdRate; // Converter BRL para USD
            const revenueBRL = revenue;
            const marginUSD = revenueUSD - usageCostUSD;
            const marginBRL = revenueBRL - usageCostBRL;
            const marginPct = revenueUSD > 0 ? (marginUSD / revenueUSD) * 100 : 0;
            const isProfitable = marginUSD > 0;
            
            return {
                x: usageCostBRL,  // UsageCost em BRL no eixo X
                y: revenueBRL,    // Revenue em BRL no eixo Y
                tenant: tenantNames[tenant.tenant_id] || 'Tenant Desconhecido',
                tenantId: tenant.tenant_id,
                marginBRL: marginBRL,
                marginUSD: marginUSD,
                marginPct: marginPct,
                isProfitable: isProfitable,
                conversations: conversations,
                aiInteractions: aiInteractions,
                chatMinutes: chatMinutes,
                // Dados extras para tooltip
                usageCostUSD: usageCostUSD,
                usageCostBRL: usageCostBRL,
                revenueUSD: revenueUSD,
                revenueBRL: revenueBRL
            };
        });
        
        return res.json({
            success: true,
            data: {
                datasets: [{
                    label: 'Tenants (Receita vs Custo de Uso)',
                    data: chartData,
                    backgroundColor: chartData.map((point: any) => {
                        // Verde se lucrativo, vermelho se preju√≠zo, amarelo se pr√≥ximo do breakeven
                        if (point.marginPct > 20) return '#28a745'; // Verde - lucrativo
                        if (point.marginPct > 0) return '#ffc107';  // Amarelo - baixa margem
                        return '#dc3545'; // Vermelho - preju√≠zo
                    }),
                    borderColor: '#2D5A9B',
                    borderWidth: 2,
                    pointRadius: 8,
                    pointHoverRadius: 10
                }],
                metadata: {
                    period_days: periodDays,
                    total_tenants: chartData.length,
                    profitable_tenants: chartData.filter((t: any) => t.isProfitable).length,
                    unprofitable_tenants: chartData.filter((t: any) => !t.isProfitable).length,
                    low_margin_tenants: chartData.filter((t: any) => t.isProfitable && t.marginPct < 20).length,
                    usd_to_brl_rate: usdRate,
                    axis_labels: {
                        x: 'Custo de Uso (R$ BRL)',
                        y: 'Receita (R$ BRL)'
                    },
                    total_platform: {
                        revenue_brl: chartData.reduce((sum, t) => sum + t.revenueBRL, 0),
                        usage_cost_brl: chartData.reduce((sum, t) => sum + t.usageCostBRL, 0),
                        margin_brl: chartData.reduce((sum, t) => sum + t.marginBRL, 0)
                    }
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de gr√°fico Revenue vs UsageCost:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * GET /api/super-admin/charts/appointment-status
 * Dados para o gr√°fico de Status dos Agendamentos (donut)
 */
router.get('/charts/appointment-status', async (req, res) => {
    try {
        const { period = '30' } = req.query;
        const periodDays = parseInt(period as string);
        const client = getAdminClientExtended();
        
        console.log(`üìä Buscando status de agendamentos para per√≠odo: ${periodDays} dias`);
        
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - periodDays);
        
        // Buscar status dos agendamentos agregados
        const { data: statusData, error } = await client
            .from('appointments')
            .select('status')
            .gte('created_at', startDate.toISOString());
            
        if (error) {
            console.error('‚ùå Erro ao buscar status de agendamentos:', error);
            // Retornar dados mock se houver erro
            return res.json({
                success: true,
                data: {
                    labels: ['Confirmados', 'Cancelados', 'Remarcados', 'Pendentes', 'Conclu√≠dos'],
                    datasets: [{
                        data: [45, 12, 8, 15, 67],
                        backgroundColor: [
                            '#17a2b8', // Info - Confirmados
                            '#dc3545', // Danger - Cancelados  
                            '#ffc107', // Warning - Remarcados
                            '#6c757d', // Secondary - Pendentes
                            '#28a745'  // Success - Conclu√≠dos
                        ]
                    }],
                    metadata: {
                        period_days: periodDays,
                        is_mock_data: true
                    }
                }
            });
        }
        
        // Contar status
        const statusCounts = {
            confirmed: 0,
            cancelled: 0,
            rescheduled: 0, 
            pending: 0,
            completed: 0
        };
        
        (statusData || []).forEach(appointment => {
            const status = appointment.status?.toLowerCase() || 'pending';
            if (status.includes('confirm')) statusCounts.confirmed++;
            else if (status.includes('cancel')) statusCounts.cancelled++;
            else if (status.includes('reschedul')) statusCounts.rescheduled++;
            else if (status.includes('complet')) statusCounts.completed++;
            else statusCounts.pending++;
        });
        
        return res.json({
            success: true,
            data: {
                labels: ['Confirmados', 'Cancelados', 'Remarcados', 'Pendentes', 'Conclu√≠dos'],
                datasets: [{
                    data: [
                        statusCounts.confirmed,
                        statusCounts.cancelled,
                        statusCounts.rescheduled,
                        statusCounts.pending,
                        statusCounts.completed
                    ],
                    backgroundColor: [
                        '#17a2b8', // Info
                        '#dc3545', // Danger
                        '#ffc107', // Warning  
                        '#6c757d', // Secondary
                        '#28a745'  // Success
                    ]
                }],
                metadata: {
                    period_days: periodDays,
                    total_appointments: statusData?.length || 0
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de status de agendamentos:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * GET /api/super-admin/insights/distortion
 * Top tenants com maior distor√ß√£o receita/uso
 */
router.get('/insights/distortion', async (req, res) => {
    try {
        const { period = '30', limit = '3' } = req.query;
        const periodDays = parseInt(period as string);
        const limitNum = parseInt(limit as string);
        const client = getAdminClientExtended();
        
        console.log(`üí° Buscando insights de distor√ß√£o para per√≠odo: ${periodDays} dias`);
        
        // Buscar tenants com m√©tricas enriquecidas da tabela tenant_metrics
        const { data: distortionData, error } = await client
            .from('tenant_metrics')
            .select('tenant_id, metric_data')
            .eq('metric_type', 'participation')
            .eq('period', `${periodDays}d`)
            .limit(limitNum * 3); // Buscar mais para filtrar depois
            
        if (error) {
            console.error('‚ùå Erro ao buscar dados de distor√ß√£o:', error);
            return res.status(500).json({
                success: false,
                error: 'Erro ao buscar insights de distor√ß√£o'
            });
        }
        
        // Buscar nomes dos tenants
        const tenantIds = distortionData?.map(t => t.tenant_id) || [];
        const { data: tenantsInfo } = await client
            .from('tenants')
            .select('id, business_name')
            .in('id', tenantIds);
        
        const tenantNames: {[key: string]: string} = {};
        (tenantsInfo || []).forEach((tenant: any) => {
            tenantNames[tenant.id] = tenant.business_name || 'Tenant Desconhecido';
        });
        
        // Processar dados de distor√ß√£o da estrutura JSONB
        const insights = (distortionData || [])
            .map((tenant: any) => {
                const metricData = tenant.metric_data || {};
                const revenue = metricData.revenue?.participation_value || 79.90;
                const chatDuration = metricData.ai_interactions?.avg_chat_duration_minutes || 0;
                const ratio = chatDuration > 0 ? revenue / chatDuration : 0;
                
                return {
                    tenant_id: tenant.tenant_id,
                    tenant_name: tenantNames[tenant.tenant_id] || 'Tenant Desconhecido',
                    ratio: ratio,
                    revenue: revenue,
                    usage_minutes: chatDuration,
                    description: `Paga R$ ${ratio.toFixed(2)} por minuto de chat`
                };
            })
            .filter(t => t.ratio > 5) // Filtrar apenas tenants com alta distor√ß√£o
            .sort((a, b) => b.ratio - a.ratio)
            .slice(0, limitNum);
        
        return res.json({
            success: true,
            data: {
                distortion_tenants: insights,
                metadata: {
                    period_days: periodDays,
                    total_found: insights.length
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de insights de distor√ß√£o:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * GET /api/super-admin/insights/upsell
 * Oportunidades de upsell (usam mais que pagam)
 */
router.get('/insights/upsell', async (req, res) => {
    try {
        const { period = '30', limit = '3' } = req.query;
        const periodDays = parseInt(period as string);
        const limitNum = parseInt(limit as string);
        const client = getAdminClientExtended();
        
        console.log(`üí∞ Buscando oportunidades de upsell para per√≠odo: ${periodDays} dias`);
        
        // Buscar tenants com m√©tricas enriquecidas da tabela tenant_metrics
        const { data: upsellData, error } = await client
            .from('tenant_metrics')
            .select('tenant_id, metric_data')
            .eq('metric_type', 'participation')
            .eq('period', `${periodDays}d`)
            .limit(limitNum * 3); // Buscar mais para filtrar depois
            
        if (error) {
            console.error('‚ùå Erro ao buscar oportunidades de upsell:', error);
            return res.status(500).json({
                success: false,
                error: 'Erro ao buscar oportunidades de upsell'
            });
        }
        
        // Buscar nomes dos tenants
        const tenantIds = upsellData?.map(t => t.tenant_id) || [];
        const { data: tenantsInfo } = await client
            .from('tenants')
            .select('id, business_name')
            .in('id', tenantIds);
        
        const tenantNames: {[key: string]: string} = {};
        (tenantsInfo || []).forEach((tenant: any) => {
            tenantNames[tenant.id] = tenant.business_name || 'Tenant Desconhecido';
        });
        
        // Processar oportunidades de upsell da estrutura JSONB
        const opportunities = (upsellData || [])
            .map((tenant: any) => {
                const metricData = tenant.metric_data || {};
                const revenue = metricData.revenue?.participation_value || 79.90;
                const chatDuration = metricData.ai_interactions?.avg_chat_duration_minutes || 0;
                const ratio = chatDuration > 0 ? revenue / chatDuration : 0;
                const inverseRatio = ratio > 0 ? 1 / ratio : 0;
                
                return {
                    tenant_id: tenant.tenant_id,
                    tenant_name: tenantNames[tenant.tenant_id] || 'Tenant Desconhecido',
                    ratio: ratio,
                    revenue: revenue,
                    usage_minutes: chatDuration,
                    description: `Usa ${inverseRatio.toFixed(1)}x mais que paga`,
                    potential_increase: Math.max(0, (150 - revenue)) // Potencial de upgrade
                };
            })
            .filter(t => t.ratio < 3 && t.usage_minutes > 0) // Filtrar oportunidades reais
            .sort((a, b) => a.ratio - b.ratio) // Menor ratio = maior oportunidade
            .slice(0, limitNum);
        
        return res.json({
            success: true,
            data: {
                upsell_opportunities: opportunities,
                metadata: {
                    period_days: periodDays,
                    total_found: opportunities.length
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de oportunidades de upsell:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * POST /api/super-admin/trigger-calculation
 * Executa o c√°lculo manual das m√©tricas da plataforma
 */
router.post('/trigger-calculation', async (req, res) => {
    try {
        const { period_days = 30, calculation_date } = req.body;
        const periodDays = parseInt(period_days as string);
        const client = getAdminClientExtended();
        
        console.log(`üîß Trigger manual de c√°lculo de m√©tricas da plataforma - per√≠odo: ${periodDays} dias`);
        
        const calcDate = calculation_date || new Date().toISOString().split('T')[0];
        
        // Executar nova fun√ß√£o de m√©tricas sem redund√¢ncia
        const { data: result, error } = await (client as any).rpc('calculate_new_metrics_system', {
            p_calculation_date: calcDate,
            p_period_days: periodDays,
            p_tenant_id: null
        });
        
        if (error) {
            console.error('‚ùå Erro no c√°lculo de m√©tricas:', error);
            return res.status(500).json({
                success: false,
                error: 'Erro no c√°lculo de m√©tricas',
                details: error.message
            });
        }
        
        console.log('‚úÖ C√°lculo de m√©tricas conclu√≠do com sucesso');
        
        return res.json({
            success: true,
            data: {
                calculation_result: result,
                timestamp: new Date().toISOString(),
                period_days: periodDays,
                calculation_date: calcDate
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro no trigger de c√°lculo:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

/**
 * GET /api/super-admin/status
 * Status geral do sistema super admin
 */
router.get('/status', async (req, res) => {
    try {
        const client = getAdminClientExtended();
        
        // Verificar √∫ltima atualiza√ß√£o de m√©tricas na nova tabela platform_metrics
        const extendedClient = getAdminClientExtended();
        const { data: lastUpdate } = await extendedClient
            .from('platform_metrics')
            .select('calculation_date, created_at')
            .in('data_source', ['new_metrics_function', 'enhanced_platform_function', 'final_corrected_function', 'final_fixed_function'])
            .order('calculation_date', { ascending: false })
            .limit(1)
            .single();
            
        const lastUpdateTime = lastUpdate?.calculation_date;
        const isRecent = lastUpdateTime ? 
            (new Date().getTime() - new Date(lastUpdateTime).getTime()) < (24 * 60 * 60 * 1000) : false;
            
        return res.json({
            success: true,
            data: {
                system_status: 'operational',
                last_calculation: lastUpdateTime,
                is_recent: isRecent,
                staleness_hours: lastUpdateTime ? 
                    Math.round((new Date().getTime() - new Date(lastUpdateTime).getTime()) / (60 * 60 * 1000)) : null,
                api_version: '1.0.0-super-admin',
                timestamp: new Date().toISOString()
            }
        });
        
    } catch (error) {
        console.error('‚ùå Erro na API de status:', error);
        return res.status(500).json({
            success: false,
            error: 'Erro interno do servidor'
        });
    }
});

export default router;