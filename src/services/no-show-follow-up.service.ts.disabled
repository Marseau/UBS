/**
 * ‚úÖ CORRE√á√ÉO 4: No-Show Follow-up Service
 * Sistema autom√°tico de follow-up para no-shows
 */

import { supabaseAdmin } from '../config/database';
import cron from 'node-cron';
import { NoShowManagerService } from './no-show-manager.service';

export interface NoShowFollowUpResult {
  processed: number;
  followups_sent: number;
  errors: number;
}

export class NoShowFollowUpService {
  private noShowManager: NoShowManagerService;
  private isProcessing: boolean = false;
  private readonly FOLLOWUP_DELAY_HOURS = 2; // Follow-up 2 horas ap√≥s no-show
  private readonly MAX_FOLLOWUP_ATTEMPTS = 2; // M√°ximo 2 tentativas

  constructor() {
    this.noShowManager = new NoShowManagerService();
  }

  /**
   * ‚úÖ Iniciar sistema de follow-up autom√°tico
   */
  start(): void {
    // Executar a cada hora para verificar no-shows pendentes de follow-up
    cron.schedule('0 * * * *', async () => {
      if (this.isProcessing) {
        console.log('‚ö†Ô∏è [NO-SHOW-FOLLOWUP] Processamento anterior ainda em andamento');
        return;
      }

      this.isProcessing = true;

      try {
        console.log('üîÑ [NO-SHOW-FOLLOWUP] Iniciando varredura de no-shows...');
        const result = await this.processNoShowFollowUps();

        console.log(`‚úÖ [NO-SHOW-FOLLOWUP] Processamento conclu√≠do:`, {
          processados: result.processed,
          followups_enviados: result.followups_sent,
          erros: result.errors
        });

      } catch (error) {
        console.error('‚ùå [NO-SHOW-FOLLOWUP] Erro cr√≠tico:', error);
      } finally {
        this.isProcessing = false;
      }
    });

    console.log('‚úÖ [NO-SHOW-FOLLOWUP] Sistema iniciado - verifica√ß√£o a cada hora');
  }

  /**
   * ‚úÖ Processar no-shows que precisam de follow-up
   */
  async processNoShowFollowUps(): Promise<NoShowFollowUpResult> {
    const stats = {
      processed: 0,
      followups_sent: 0,
      errors: 0
    };

    try {
      // Buscar appointments com status 'no_show' que ainda n√£o receberam follow-up
      // ou que s√£o eleg√≠veis para segundo follow-up
      const cutoffTime = new Date();
      cutoffTime.setHours(cutoffTime.getHours() - this.FOLLOWUP_DELAY_HOURS);

      const { data: noShows, error } = await supabaseAdmin
        .from('appointments')
        .select(`
          *,
          users!inner(name, phone),
          tenants!inner(business_name, whatsapp_phone)
        `)
        .eq('status', 'no_show')
        .lt('start_time', cutoffTime.toISOString())
        .is('followup_attempts', null)
        .or('followup_attempts.lt.2')
        .limit(50);

      if (error || !noShows) {
        console.warn('‚ö†Ô∏è [NO-SHOW-FOLLOWUP] Erro ao buscar no-shows:', error);
        return stats;
      }

      console.log(`üìã [NO-SHOW-FOLLOWUP] Encontrados ${noShows.length} no-shows para follow-up`);

      for (const appointment of noShows) {
        try {
          stats.processed++;

          const followupAttempts = (appointment as any).followup_attempts || 0;

          // Verificar se pode enviar follow-up
          if (followupAttempts >= this.MAX_FOLLOWUP_ATTEMPTS) {
            continue;
          }

          // Determinar tipo de follow-up baseado no n√∫mero de tentativas
          const followupType = followupAttempts === 0 ? 'first_followup' : 'second_followup';

          await this.sendNoShowFollowUp(appointment, followupType);

          // Atualizar contador de tentativas
          await supabaseAdmin
            .from('appointments')
            .update({
              followup_attempts: followupAttempts + 1,
              last_followup_at: new Date().toISOString()
            } as any)
            .eq('id', appointment.id);

          stats.followups_sent++;

          console.log(`üìß [NO-SHOW-FOLLOWUP] Follow-up enviado para appointment ${appointment.id}`);

        } catch (error) {
          stats.errors++;
          console.error(`‚ùå [NO-SHOW-FOLLOWUP] Erro ao processar appointment ${appointment.id}:`, error);
        }
      }

      return stats;

    } catch (error) {
      console.error('‚ùå [NO-SHOW-FOLLOWUP] Erro cr√≠tico no processamento:', error);
      stats.errors++;
      return stats;
    }
  }

  /**
   * ‚úÖ Enviar follow-up espec√≠fico para no-show
   */
  private async sendNoShowFollowUp(appointment: any, followupType: 'first_followup' | 'second_followup'): Promise<void> {
    try {
      const user = appointment.users;
      const tenant = appointment.tenants;

      let followupMessage = '';

      if (followupType === 'first_followup') {
        followupMessage = `Ol√° ${user.name}! üëã

Notamos que voc√™ n√£o compareceu ao seu agendamento hoje. Esperamos que esteja tudo bem!

Gostar√≠amos de reagendar seu atendimento. Que tal escolhermos um novo hor√°rio que seja mais conveniente para voc√™?

Aguardamos seu retorno! üòä

Atenciosamente,
${tenant.business_name}`;
      } else {
        followupMessage = `Ol√° ${user.name}!

Este √© nosso segundo contato sobre o reagendamento do seu atendimento.

Entendemos que imprevistos acontecem e estamos aqui para ajudar voc√™ a encontrar um hor√°rio que funcione melhor.

Se n√£o tiver mais interesse nos nossos servi√ßos, nos informe para que possamos atualizar nossos registros.

Obrigado pela compreens√£o! üôè

${tenant.business_name}`;
      }

      // Log do follow-up (integra√ß√£o com WhatsApp seria aqui)
      console.log(`üìß [NO-SHOW-FOLLOWUP] Enviando ${followupType} para ${user.phone}: "${followupMessage.substring(0, 100)}..."`);

      // Registrar follow-up no hist√≥rico de conversas
      await supabaseAdmin
        .from('conversation_history')
        .insert({
          tenant_id: appointment.tenant_id,
          user_id: user.phone, // Use phone as user_id
          content: followupMessage,
          message_type: 'outbound',
          conversation_outcome: `no_show_${followupType}`,
          is_from_user: false,
          session_id_uuid: `noshow_${appointment.id}_${Date.now()}`,
          conversation_context: {
            appointment_id: appointment.id,
            followup_type: followupType,
            followup_reason: 'no_show_automatic_followup'
          },
          created_at: new Date().toISOString()
        });

      console.log(`‚úÖ [NO-SHOW-FOLLOWUP] Follow-up registrado para appointment ${appointment.id}`);

    } catch (error) {
      console.error(`‚ùå [NO-SHOW-FOLLOWUP] Erro ao enviar follow-up:`, error);
      throw error;
    }
  }

  /**
   * ‚úÖ Executar processamento manual (para testes)
   */
  async executeManually(): Promise<NoShowFollowUpResult> {
    console.log('üîß [NO-SHOW-FOLLOWUP] Execu√ß√£o manual iniciada...');
    return await this.processNoShowFollowUps();
  }

  /**
   * ‚úÖ Obter estat√≠sticas do sistema
   */
  async getStatistics(): Promise<{
    pending_followups: number;
    followups_sent_today: number;
    no_shows_today: number;
  }> {
    try {
      const today = new Date().toISOString().split('T')[0];

      // No-shows pendentes de follow-up
      const { data: pendingFollowups } = await supabaseAdmin
        .from('appointments')
        .select('id', { count: 'exact' })
        .eq('status', 'no_show')
        .is('followup_attempts', null)
        .or('followup_attempts.lt.2');

      // Follow-ups enviados hoje
      const { data: followupsSentToday } = await supabaseAdmin
        .from('conversation_history')
        .select('id', { count: 'exact' })
        .like('conversation_outcome', 'no_show_%followup')
        .gte('created_at', `${today}T00:00:00`)
        .lt('created_at', `${today}T23:59:59`);

      // No-shows de hoje
      const { data: noShowsToday } = await supabaseAdmin
        .from('appointments')
        .select('id', { count: 'exact' })
        .eq('status', 'no_show')
        .gte('start_time', `${today}T00:00:00`)
        .lt('start_time', `${today}T23:59:59`);

      return {
        pending_followups: (pendingFollowups as any)?.length || 0,
        followups_sent_today: (followupsSentToday as any)?.length || 0,
        no_shows_today: (noShowsToday as any)?.length || 0
      };

    } catch (error) {
      console.error('‚ùå [NO-SHOW-FOLLOWUP] Erro ao buscar estat√≠sticas:', error);
      return {
        pending_followups: 0,
        followups_sent_today: 0,
        no_shows_today: 0
      };
    }
  }
}

// Singleton instance
let noShowFollowUpInstance: NoShowFollowUpService | null = null;

export function getNoShowFollowUpService(): NoShowFollowUpService {
  if (!noShowFollowUpInstance) {
    noShowFollowUpInstance = new NoShowFollowUpService();
  }
  return noShowFollowUpInstance;
}

export function startNoShowFollowUp(): void {
  const service = getNoShowFollowUpService();
  service.start();
}